- [第2章 指针操作](#orgdd36e60)
  - [指针基础](#orgcd2b93c)
  - [存储空间分配](#org027c365)
  - [数据集合与指针的算数运算](#orgf33c192)
    - [结构](#orgfd00772)
    - [数组](#org8941201)
  - [作为函数参数的指针](#org57f0f95)
  - [按引用调用传递参数](#orga3c02f6)
  - [作为参数指向指针的指针](#org6e5f85c)
  - [泛型指针与类型转换](#orgc37ee30)
    - [泛型指针](#org2bc80cf)
    - [类型转换](#orgd039f9f)
  - [函数指针](#org0ca5da1)



<a id="orgdd36e60"></a>

# 第2章 指针操作


<a id="orgcd2b93c"></a>

## 指针基础

一个指针只是一个变量,它存储数据在内存中的地址.


<a id="org027c365"></a>

## 存储空间分配

当声明一个指针时,仅仅只为该指针本身分配空间,并没有为指针所引用的数据分配空间.


<a id="orgf33c192"></a>

## 数据集合与指针的算数运算

数据集合: 结构和数组


<a id="orgfd00772"></a>

### 结构

结构由任意的有序的元素构成,类似 Product Type.

```c
typedef struct ListElmt_{
void* data;
struct ListElmt_* next;
}
```

结构不允许包含自身的实例,但可以包含指向自身实例的指针.


<a id="org8941201"></a>

### 数组

数组是内存中连续排列的同类元素的序列. a[i] `= *(a+i) a[i][j] =` \*(​\*(a + i) + j)​ ​


<a id="org57f0f95"></a>

## 作为函数参数的指针

按引用传递参数时,当函数改变此参数时,这个被改变的值会一直存在,甚至函数退出后仍然存在. 使用指针传递大容量复制的函数参数.


<a id="orga3c02f6"></a>

## 按引用调用传递参数

通常情况下,c语言只支持按值传参(pass by value).但我们可以模仿按引用调用传递参数(pass by reference)将一个指向参数的指针传递给函数.


<a id="org6e5f85c"></a>

## 作为参数指向指针的指针

作为参数指向指针的指针,是因为在函数想改变传递给它的指针.


<a id="orgc37ee30"></a>

## 泛型指针与类型转换

使用泛型指针模拟泛型.泛型指针并不指定具体的数据类型.


<a id="org2bc80cf"></a>

### 泛型指针

通常情况下,c语言只允许相同类型的指针之间进行转换.但是泛型指针能够转换为任何类型的指针,反之亦然.


<a id="orgd039f9f"></a>

### 类型转换

将类型T的变量t转换为类型S的变量s.只需要 (S)t. 可能破坏内存中的数据对齐.


<a id="org0ca5da1"></a>

## 函数指针
