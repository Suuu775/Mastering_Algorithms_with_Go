#+title: Mastering Algorithms with C
#+description: the note of "Mastering Algorithms with C"
#+author: Su

* 第2章 指针操作
** 指针基础
一个指针只是一个变量,它存储数据在内存中的地址.
** 存储空间分配
当声明一个指针时,仅仅只为该指针本身分配空间,并没有为指针所引用的数据分配空间.
** 数据集合与指针的算数运算
数据集合: 结构和数组
*** 结构
结构由任意的有序的元素构成,类似 Product Type.
#+begin_src c
typedef struct ListElmt_{
void* data;
struct ListElmt_* next;
}
#+end_src
结构不允许包含自身的实例,但可以包含指向自身实例的指针.
*** 数组
数组是内存中连续排列的同类元素的序列.
a[i] == *(a+i)
a[i][j] == *(​*(a + i) + j)​
​
** 作为函数参数的指针
按引用传递参数时,当函数改变此参数时,这个被改变的值会一直存在,甚至函数退出后仍然存在.
使用指针传递大容量复制的函数参数.
** 按引用调用传递参数
通常情况下,c语言只支持按值传参(pass by value).但我们可以模仿按引用调用传递参数(pass by reference)将一个指向参数的指针传递给函数.
** 作为参数指向指针的指针
作为参数指向指针的指针,是因为在函数想改变传递给它的指针.
** 泛型指针与类型转换
使用泛型指针模拟泛型.泛型指针并不指定具体的数据类型.
*** 泛型指针
通常情况下,c语言只允许相同类型的指针之间进行转换.但是泛型指针能够转换为任何类型的指针,反之亦然.
*** 类型转换
将类型T的变量t转换为类型S的变量s.只需要 (S)t.
可能破坏内存中的数据对齐.
** 函数指针
函数指针是指向可执行代码段或调用可执行代码段的信息块的指针,而不是指向某种数据的指针.
声明函数指针的形式: return-value (*function-name) (args...).
调用形式与调用函数相同.
函数指针的一个重要用途是将函数封装到数据结构中.

* 第3章 递归
** 基本递归
基本递归过程有两个基本阶段: 递推和回归
一个可执行程序由4个区域构成: 代码段,静态数据区,堆和栈.
代码段包含程序运行所执行的机器指令,静态数据区包含在程序生命周期内一直持久的数据,如全局变量和静态局部变量.
堆包含程序运行时动态分配的存储数据,栈包含函数调用的信息.
堆的增长方向由程序低地址向高地址增长,栈则相反.
当c程序调用了一个函数时,栈中会分配一块空间保存调用相关信息,称为栈帧.

** 尾递归
在基本递归的基础上,尾递归在回归过程中不执行操作.编译器可以优化此函数.

* 第4章 算法分析
** 最坏情况分析
分析算法的最佳情况的性能没有太多意义.
分析算法的平均情况的性能不那么容易.
分析算法的最坏情况可以告诉我们算法性能的上限.
** 大O表示法
大O表示法的基本规则: 优化常数项和常数因子,只考虑高阶项的因子.
** 计算的复杂度
使用上述两种方法完成计算的复杂度分析
* 第5章 链表
** 单链表介绍
单链表由各个元素之间通过一个指针彼此链接起来而组成.每个元素包含两部分: 数据成员和一个称为next的指针.将每一个元素next指针设置为指向后面的元素.最后一个元素的next指针指向NULL.
** 单链表接口的定义
*** list_init
#+begin_src c
void list_init(List* list,void (*destroy) (void* data));
#+end_src
返回值: 无.
描述: 初始化有参数 list 指定的链表,该函数必须在链表做其他操作之前调用.destroy 参数提供了一种释放动态分配的数据的方法.如果链表包含不应该释放的数据或者不需要动态释放空间的数据时,destroy应该设置为 NULL.
复杂度: O(1).
*** list_destroy
#+begin_src c
void list_destroy(List* list);
#+end_src
返回值: 无.
描述: 销毁由参数list指定的链表,调用list_destroy后不允许执行其他关于此list的操作.list_destroy 将链表中的所有元素都移除,如果list_init中的destroy不为NULL,则移除链表中每个元素时都调用该函数一次.
复杂度: O(n),n为链表的长度.
*** list_ins_next
#+begin_src c
int list_ins_next(List *list,ListElmt *element,const void *data);
#+end_src
返回值: 插入元素成功则返回0,否则返回-1.
描述: 在list指定的链表中element后面插入一个新元素,如果element为NULL,则新链表插入链表头部.新元素包含一个指向data的指针,因此只要该元素还在链表中,data所引用的内存应该保持合法.管理data所引用的储存空间是调用者的责任.
复杂度: O(1).
*** list_rem_next
#+begin_src c
int list_ins_next(List *list,ListElmt *element,void **data);
#+end_src
返回值: 删除元素成功则返回0,否则返回-1.
描述:与list_ins_next,只不过由插入改为删除.
复杂度: O(1).
*** list_size
#+begin_src c
int list_size(const List *list);
#+end_src
返回值: 链表中元素的个数.
描述: 这是一个宏,用来计算由参数list指定的链表中的元素的个数.
复杂度:O(1).
*** list_head
#+begin_src c
ListElmt *list_head(const List *list);
#+end_src
返回值: 指向链表中头元素的指针.
描述: 这是一个宏,返回由参数list指定的链表中头元素的指针.
复杂度: O(1).
*** list_tail
#+begin_src c
ListElmt *list_tail(const List *list);
#+end_src
返回值: 指向链表中尾元素的指针.
描述: 这是一个宏,返回由参数list指定的链表中尾元素的指针.
复杂度: O(1).
*** list_is_head
#+begin_src c
int list_is_head(const ListElmt *element);
#+end_src
返回值: 如果element所指定的元素是链表头节点则返回1;否则返回-1.
描述: 这是一个宏,用来判断element所指定的元素是否是链表的链表头结点.
复杂度: O(1).
*** list_is_tail
#+begin_src c
int list_is_tail(const ListElmt *element);
#+end_src
返回值: 如果element所指定的元素是链表尾节点则返回1;否则返回-1.
描述: 这是一个宏,用来判断element所指定的元素是否是链表的链表头结点.
复杂度: O(1).
*** list_data
#+begin_src c
void *list_data(const ListElmt *element);
#+end_src
返回值: 节点中保存的数据.
描述: 这是一个宏,返回由element所指定的链表结点元素保存的数据.
复杂度: O(1).
*** list_next
#+begin_src c
ListElmt *list_next(const ListElmt *element);
#+end_src
返回值: 返回由参数element指定的节点的下一个节点.
描述: 这是一个宏,返回由参数element指定的节点的下一个节点.
复杂度: O(1).
** 单链表的实现
[[file:src/ch5/list.go][单链表]]
** 双向链表介绍
双向链表元素之间由两个指针链接,双向链表的每一个元素由三部分组成: data,prev,next.
为了标识链表的头与尾,将第一个元素的prev指针与最后一个元素的next指针设置为 nil.
** 双向链表接口的定义
*** DList_init
#+begin_src go
func DList_init() *DList
#+end_src
返回值: 指向DList.
描述: 初始化双向链表.
复杂度: O(1).
*** Destroy
#+begin_src go
func (lst *DList) Destroy()
#+end_src
返回值: 无.
描述: 销毁由参数lst指定的链表.
复杂度: O(n).
*** Ins_next
#+begin_src go
func (lst *DList) Ins_next(element *DListElmt,data any) error
#+end_src
返回值: 如果插入成功返回 nil,否则返回具体错误.
描述: 将data插入由list指定的双向链表中element之后,element当且仅当lst为空列表时才能为nil.
复杂度: O(1).
*** Ins_prev
#+begin_src go
func (lst *DList) Ins_prev(element *DListElmt ,data any) error
#+end_src
返回值: 如果插入成功返回nil,否则返回具体错误.
描述: 将data插入由list指定的双向链表中element之前,element当且仅当lst为空列表时才能为nil.
复杂度: O(1).
*** Remove
#+begin_src go
func (lst *DList) Remove(element *DListElmt) (any, error)
#+end_src
返回值: 如果移除成功,返回(value,nil),否则返回(nil,error)
描述: 从lst指向的双向链表中移除由element指定的元素.
复制度: O(1)
** 双向链表的实现
[[file:src/ch5/dlist.go][双向链表]]
** 循环链表的介绍
在单向循环链表中,最后一个元素的next指针又指回头元素而不是设置为nil.
在双向循环链表中,头元素的prev指针则指向最后一个元素.
** 循环链表接口的定义
** 循环链表的实现

