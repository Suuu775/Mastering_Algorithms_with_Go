#+title: Mastering Algorithms with Go
#+description: the note of "Mastering Algorithms with C"
#+author: Su

* 第2章 指针操作
** 指针基础
一个指针只是一个变量,它存储数据在内存中的地址.
** 存储空间分配
当声明一个指针时,仅仅只为该指针本身分配空间,并没有为指针所引用的数据分配空间.
** 数据集合与指针的算数运算
数据集合: 结构和数组
*** 结构
结构由任意的有序的元素构成,类似 Product Type.
#+begin_src c
typedef struct ListElmt_{
void* data;
struct ListElmt_* next;
}
#+end_src
结构不允许包含自身的实例,但可以包含指向自身实例的指针.
*** 数组
数组是内存中连续排列的同类元素的序列.
a[i] == *(a+i)
a[i][j] == *(​*(a + i) + j)​
​
** 作为函数参数的指针
按引用传递参数时,当函数改变此参数时,这个被改变的值会一直存在,甚至函数退出后仍然存在.
使用指针传递大容量复制的函数参数.
** 按引用调用传递参数
通常情况下,c语言只支持按值传参(pass by value).但我们可以模仿按引用调用传递参数(pass by reference)将一个指向参数的指针传递给函数.
** 作为参数指向指针的指针
作为参数指向指针的指针,是因为在函数想改变传递给它的指针.
** 泛型指针与类型转换
使用泛型指针模拟泛型.泛型指针并不指定具体的数据类型.
*** 泛型指针
通常情况下,c语言只允许相同类型的指针之间进行转换.但是泛型指针能够转换为任何类型的指针,反之亦然.
*** 类型转换
将类型T的变量t转换为类型S的变量s.只需要 (S)t.
可能破坏内存中的数据对齐.
** 函数指针
函数指针是指向可执行代码段或调用可执行代码段的信息块的指针,而不是指向某种数据的指针.
声明函数指针的形式: return-value (*function-name) (args...).
调用形式与调用函数相同.
函数指针的一个重要用途是将函数封装到数据结构中.

* 第3章 递归
** 基本递归
基本递归过程有两个基本阶段: 递推和回归
一个可执行程序由4个区域构成: 代码段,静态数据区,堆和栈.
代码段包含程序运行所执行的机器指令,静态数据区包含在程序生命周期内一直持久的数据,如全局变量和静态局部变量.
堆包含程序运行时动态分配的存储数据,栈包含函数调用的信息.
堆的增长方向由程序低地址向高地址增长,栈则相反.
当c程序调用了一个函数时,栈中会分配一块空间保存调用相关信息,称为栈帧.

** 尾递归
在基本递归的基础上,尾递归在回归过程中不执行操作.编译器可以优化此函数.

* 第4章 算法分析
** 最坏情况分析
分析算法的最佳情况的性能没有太多意义.
分析算法的平均情况的性能不那么容易.
分析算法的最坏情况可以告诉我们算法性能的上限.
** 大O表示法
大O表示法的基本规则: 优化常数项和常数因子,只考虑高阶项的因子.
** 计算的复杂度
使用上述两种方法完成计算的复杂度分析
* 第5章 链表
** 单链表介绍
单链表由各个元素之间通过一个指针彼此链接起来而组成.每个元素包含两部分: 数据成员和一个称为next的指针.将每一个元素next指针设置为指向后面的元素.最后一个元素的next指针指向NULL.
** 单链表接口的定义
*** list_init
#+begin_src c
void list_init(List* list,void (*destroy) (void* data));
#+end_src
返回值: 无.
描述: 初始化有参数 list 指定的链表,该函数必须在链表做其他操作之前调用.destroy 参数提供了一种释放动态分配的数据的方法.如果链表包含不应该释放的数据或者不需要动态释放空间的数据时,destroy应该设置为 NULL.
复杂度: O(1).
*** list_destroy
#+begin_src c
void list_destroy(List* list);
#+end_src
返回值: 无.
描述: 销毁由参数list指定的链表,调用list_destroy后不允许执行其他关于此list的操作.list_destroy 将链表中的所有元素都移除,如果list_init中的destroy不为NULL,则移除链表中每个元素时都调用该函数一次.
复杂度: O(n),n为链表的长度.
*** list_ins_next
#+begin_src c
int list_ins_next(List *list,ListElmt *element,const void *data);
#+end_src
返回值: 插入元素成功则返回0,否则返回-1.
描述: 在list指定的链表中element后面插入一个新元素,如果element为NULL,则新链表插入链表头部.新元素包含一个指向data的指针,因此只要该元素还在链表中,data所引用的内存应该保持合法.管理data所引用的储存空间是调用者的责任.
复杂度: O(1).
*** list_rem_next
#+begin_src c
int list_ins_next(List *list,ListElmt *element,void **data);
#+end_src
返回值: 删除元素成功则返回0,否则返回-1.
描述:与list_ins_next,只不过由插入改为删除.
复杂度: O(1).
*** list_size
#+begin_src c
int list_size(const List *list);
#+end_src
返回值: 链表中元素的个数.
描述: 这是一个宏,用来计算由参数list指定的链表中的元素的个数.
复杂度:O(1).
*** list_head
#+begin_src c
ListElmt *list_head(const List *list);
#+end_src
返回值: 指向链表中头元素的指针.
描述: 这是一个宏,返回由参数list指定的链表中头元素的指针.
复杂度: O(1).
*** list_tail
#+begin_src c
ListElmt *list_tail(const List *list);
#+end_src
返回值: 指向链表中尾元素的指针.
描述: 这是一个宏,返回由参数list指定的链表中尾元素的指针.
复杂度: O(1).
*** list_is_head
#+begin_src c
int list_is_head(const ListElmt *element);
#+end_src
返回值: 如果element所指定的元素是链表头节点则返回1;否则返回-1.
描述: 这是一个宏,用来判断element所指定的元素是否是链表的链表头结点.
复杂度: O(1).
*** list_is_tail
#+begin_src c
int list_is_tail(const ListElmt *element);
#+end_src
返回值: 如果element所指定的元素是链表尾节点则返回1;否则返回-1.
描述: 这是一个宏,用来判断element所指定的元素是否是链表的链表头结点.
复杂度: O(1).
*** list_data
#+begin_src c
void *list_data(const ListElmt *element);
#+end_src
返回值: 节点中保存的数据.
描述: 这是一个宏,返回由element所指定的链表结点元素保存的数据.
复杂度: O(1).
*** list_next
#+begin_src c
ListElmt *list_next(const ListElmt *element);
#+end_src
返回值: 返回由参数element指定的节点的下一个节点.
描述: 这是一个宏,返回由参数element指定的节点的下一个节点.
复杂度: O(1).
** 单链表的实现
[[file:src/ch5/list.go][单链表]]
** 双向链表介绍
双向链表元素之间由两个指针链接,双向链表的每一个元素由三部分组成: data,prev,next.
为了标识链表的头与尾,将第一个元素的prev指针与最后一个元素的next指针设置为 nil.
** 双向链表接口的定义
*** DList_init
#+begin_src go
func DList_init() *DList
#+end_src
返回值: 指向DList的指针.
描述: 初始化双向链表.
复杂度: O(1).
*** Destroy
#+begin_src go
func (lst *DList) Destroy()
#+end_src
返回值: 无.
描述: 销毁由参数lst指定的链表.
复杂度: O(n).
*** Ins_next
#+begin_src go
func (lst *DList) Ins_next(element *DListElmt,data any) error
#+end_src
返回值: 如果插入成功返回 nil,否则返回具体错误.
描述: 将data插入由list指定的双向链表中element之后,element当且仅当lst为空列表时才能为nil.
复杂度: O(1).
*** Ins_prev
#+begin_src go
func (lst *DList) Ins_prev(element *DListElmt ,data any) error
#+end_src
返回值: 如果插入成功返回nil,否则返回具体错误.
描述: 将data插入由list指定的双向链表中element之前,element当且仅当lst为空列表时才能为nil.
复杂度: O(1).
*** Remove
#+begin_src go
func (lst *DList) Remove(element *DListElmt) (any, error)
#+end_src
返回值: 如果移除成功,返回(value,nil),否则返回(nil,error)
描述: 从lst指向的双向链表中移除由element指定的元素.
复制度: O(1)
** 双向链表的实现
[[file:src/ch5/dlist.go][双向链表]]
** 循环链表的介绍
在单向循环链表中,最后一个元素的next指针又指回头元素而不是设置为nil.
在双向循环链表中,头元素的prev指针则指向最后一个元素.
** 循环链表接口的定义
*** CList_init
#+begin_src go
func CList_init() *CList
#+end_src
返回值: 指向CList的指针.
描述: 初始化双向链表.
复杂度: O(1).
*** Ins_next
#+begin_src go
func (lst *CList) Ins_next(element *CListElmt,data any) error
#+end_src
返回值: 如果插入成功返回 nil,否则返回具体错误.
描述: 将data插入由list指定的循环链表中element之后,element当且仅当lst为空列表时才能为nil.
复杂度: O(1).
*** Rem_next
#+begin_src go
func (lst *CList) Rem_next(element *CListElmt) (any,error)
#+end_src
返回值: 如果移除成功,返回(value,nil),否则返回(nil,error)
描述: 从lst指向的循环链表中移除由element指定的元素.
复杂度: O(1)
** 循环链表的实现
[[file:src/ch5/clist.go][循环链表]]
* 第6章 栈和队列
** 栈的描述
栈的一个显著特征是它按照先进后出的方式储存和删除元素(FILO).
** 栈的接口的定义
*** NewStack
#+begin_src go
func NewStack() *Stack
#+end_src
返回值: 返回指向栈的指针
描述: 初始化栈
复杂度: O(1)
*** Push
#+begin_src go
func (s *Stack) Push(data any)
#+end_src
返回值: 无
描述: 将data推入栈
复杂度: O(1)
*** Pop
#+begin_src go
func (s *Stack) Pop() (any, error)
#+end_src
返回值: (any,error)
描述: 将栈顶的data推出(如果有)
复杂度: O(1)
*** Top
#+begin_src go
func (s *Stack) Top() any
#+end_src
返回值:栈顶的数据
描述: 返回栈顶的数据
复杂度: O(1)
*** Size
#+begin_src go
func (s *Stack) Size() int
#+end_src
返回值:栈的大小
描述:返回栈的大小
复杂度:O(1)
** 栈的实现
此栈使用单链表定义.
[[file:src/ch6/stack.go][栈]]
** 队列的描述
队列的一个显著特征是它按照先进先出的方式储存、检索、删除元素(FIFO).
** 队列的接口的定义
*** NewQueue
#+begin_src go
func NewQueue() *Queue
#+end_src
返回值:指向队列的指针
描述: 初始化队列
复杂度:O(1)
*** Pop
#+begin_src go
func (queue *Queue) Pop() (any,error)
#+end_src
返回值:队列头部值或错误
描述:删除首个元素
复杂度: O(1)
*** Push
#+begin_src go
func (queue *Queue) Push(data any)
#+end_src
返回值: 无
描述:向队列尾部插入元素
复杂度:O(1)
*** Front
#+begin_src go
func (queue *Queue) Front() any
#+end_src
返回值: 队列头部元素值或nil
描述: 访问第一个元素
复杂度: O(1)
*** Back
#+begin_src go
func (queue *Queue) Back() any
#+end_src
返回值: 队列尾部值或错误
描述: 访问最后一个元素
复杂度: O(1)
** 队列的实现
结构Queue是队列的数据结构.同栈一样,也用
#+begin_src go
type Queue struct{
	list *ch5.List
}
#+end_src
来定义它.
[[file:src/ch6/queue.go][queue]]
* 第7章 集合
** 集合介绍
*** 集合概念
集合是相关联成员的无序组合, 且每个成员在集合中仅出现一次.
*** 集合定义
1. 没有包含任何成员的集合称为空集. 集合的所有可能成员称为全域.
2. 如果两个集合中所包含的成员完全一样, 则称这两个集合相等.
3. 如果集合 S2 包含另一个集合 S1 所有的成员, 则 S1 是 S2 的子集.$S_{1} \in S_{2}$表示 S1 是 S2 的子集, $S_{1} \not\in S_{2}$表示 S1 不是 S2 的子集
*** 集合的基本操作
1. 两个集合 S1 和 S2 的并集也是一个集合, 记为 Su, 它包含了 S1 和 S2 中的所有成员.
2. 两个集合 S1 和 S2 的交集也是一个集合, 记为 Si, 它只包含同时存在于 S1 和 S2 中的成员.
3. 两个集合 S1 和 S2 的差集也是一个集合, 记为 Sd, 它只包含在 S1 中出现过且不属于S2 的成员.
*** 集合性质
1. 某个集合与空集的交集结果一定是空集, 某个集合与空集的并集结果还是原来的集合本身. 即$ S \cup \emptyset = S \\ S\cap \emptyset = \emptyset $
2. 与集合本身求交集结果还是集合本身, 同样的, 与集合本身求并集结果也还是集合本身. 即$S \cup S = S \quad  S \cap S = S$
3. 集合 S1 与集合 S2 的交集其结果等同于集合 S2 与集合 S1 的交集. 同样的道理也适用于并集的情况. 即$S_{1} \cup S_{2} = S_{2} \cup S_{1} \quad S_{1} \cap S_{2} = S_{2} \cap S_{1}$
4. 一组集合的交集可以按照任意顺序来求解, 同样的道理也适用于并集的情况. 即$S_{1} \cup (S_{2} \cup S_{3}) = (S_{1} \cup S_{2}) \cup S_{3} \quad S_{1} \cap (S_{2} \cap S_{3}) = (S_{1} \cap S_{2}) \cap S_{3}$
5. 某集合与其他两个集合的并集相交的结果可以按照一种分配的方式来解决, 同样的道理也适用于求解某集合与其他两个集合的交集相合并的结果. 即$A \cap (B \cup C) = (A \cap B) \cup (A \cap C) \quad A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$
6. 某集合与该集合和另一个集合的并集相交的结果等于该集合本身. 同样的道理也适用于求解某集合与该集合和另一个集合的交集相合并的结果. 即$S_{1} \cap (S_{1} \cup S_{2})=S_{1} \quad S_{1} \cup (S_{1} \cap S_{2}) = S_{1}$
7. 当求解一个集合与其他两个集合的交集或并集之差时,可以得到一个有趣的结论. 这种行为称为德摩根定律. 即$S_{1} - (S_{2} \cup S_{3}) = (S_{1} - S_{2}) \cup (S_{1} - S_{3}) \quad S_{1} - (S_{2} \cap S_{3}) = (S_{1} - S_{2}) \cap (S_{1} - S_{3})$
** 集合接口的定义
*** NewSet
#+begin_src go
func NewSet[T cmp.Ordered]() *Set[T]
#+end_src
返回值: 指向 Set 的指针.
描述: 初始化 Set.
复杂度: O(1).
*** Destroy
#+begin_src go
func (set *Set[T]) Destory()
#+end_src
返回值: 无
描述: 销毁 Set
复杂度: O(1)
*** Insert
#+begin_src go
func (set *Set[T]) Insert(key T)
#+end_src
返回值: 将 key 插入
描述: 初始化 Set.
复杂度: O(log(n)).
*** Remove
#+begin_src go
func (set *Set[T]) Remove(key T) bool
#+end_src
返回值: bool值
描述: 判断 key 是否存在于 Set, 若有则删除返回true, 反之返回 false.
复杂度: O(log(n))
*** Union
#+begin_src go
func (lhs *Set[T]) Union(rhs *Set[T]) *Set[T]
#+end_src
返回值: 指向 Set[T] 的指针
描述: 对两个 Set 计算并集, 并返回结果
复杂度: O(n+m)
*** Intersection
#+begin_src go
func (lhs *Set[T]) Intersection(rhs *Set[T]) *Set[T]
#+end_src
返回值: 指向 Set[T] 的指针
描述: 对两个 Set 计算交集, 并返回结果
复杂度: O(n+m)
*** Difference
#+begin_src go
func (lhs *Set[T]) Difference(rhs *Set[T]) *Set[T]
#+end_src
返回值: 指向 Set[T] 的指针
描述: 对两个 Set 计算差集, 并返回结果
复杂度: O(n+m)
*** IsMember
#+begin_src go
func (set *Set[T]) IsMember(key T) bool
#+end_src
返回值: bool值
描述: 判断 key 是否存在于 Set
复杂度: O(log(n))
*** IsSubset
#+begin_src go
func(lhs *Set[T]) IsSubset (rhs *Set[T]) bool
#+end_src
返回值: bool值
描述: 判断 lhs 是否为 rhs 的一个子集
复杂度: O(min(n,m))
*** IsEqual
#+begin_src go
func (lhs *Set[T]) IsEqual(rhs *Set[T]) bool
#+end_src
返回值: bool值
描述: 判断 lhs 与 rhs 是否相等
复杂度: O(min(n,m))
*** GetSize
#+begin_src go
func (set *Set[T]) GetSize() int
#+end_src
返回值: Set的大小
描述: 获取 Set 的大小
复杂度: O(1)
** 集合的实现
[[file:src/ch7/set.go][Set]]
* 第9章 树
** 二叉树介绍
*** 二叉树定义
二叉树是一种将结点按照层次结构组织起来的数据结构,每个结点最多只有两个与它直接相关联的子结点.
直接连接在结点下方的那个结点称为子结点,而与每个子结点直接相连的上方结点称为父结点.
结点也可以拥有兄弟,子孙和祖先.
二叉树中的每一个结点都包含3部分:一个数据成员和两个左右指针.每个结点的左右指针分别指向该结点的子结点.
*** 树的遍历算法
前序遍历: 给定一棵子树,首先访问它的根结点,然后是左子结点,最后是右子结点.
中序遍历: 给定一棵子树,首先访问左子结点,然后是根结点,最后是右子结点.
后序遍历: 给定一棵子树,首先访问左子结点,然后是右子结点,最后是根结点.
层级遍历: 给定一棵子树,首先访问树的根,然后依次向下层处理,按照从左到右的顺序访问每层的结点.采用广度优先算法实现.
*** 树的平衡
关于一棵搜索树是否"平衡",不同的平衡树中对"平衡"有着不同的定义.
** 二叉树的接口定义
*** NewBiTree
#+begin_src go
func NewBiTree[T comparable]() *BiTree[T]
#+end_src
返回值: 指向bitree的指针.
描述: 初始化bitree.
复杂度: O(1).
*** Ins_left
#+begin_src go
func (tree *BiTree[T]) Ins_left(node *BiTreeNode[T], data T) error
#+end_src
返回值: error 或 nil.
描述: 在指定节点的左子节点位置插入一个新节点.
复杂度: O(1).
*** Ins_right
#+begin_src go
func (tree *BiTree[T]) Ins_right(node *BiTreeNode[T], data T) error
#+end_src
返回值: error 或 nil.
描述: 在指定节点的右子节点位置插入一个新节点.
复杂度: O(1).
*** Remove_left
#+begin_src go
func (t *BiTree[T]) Remove_left(node *BiTreeNode[T])
#+end_src
返回值: 无
描述: 移除指定节点的左子树.
复杂度: O(n) n为子树的节点个数.
*** Remove_right
#+begin_src go
func (t *BiTree[T]) Remove_right(node *BiTreeNode[T])
#+end_src
返回值: 无.
描述: 移除指定节点的右子树.
复杂度: O(n)  n为子树的节点个数.
*** Bitree_merge
#+begin_src go
func Bitree_merge[T comparable](merge *BiTree[T], left *BiTree[T], right *BiTree[T], data T) error
#+end_src
返回值: error 或 nil.
描述: 将两棵二叉树合并为单棵二叉树.
复杂度: O(1).
*** bitree_size、bitree_root、bitree_is_eob、bitree_data、bitree_left和bitree_right
描述: 关于二叉树的一些简单操作.
复杂度: O(1).
** 二叉树的实现
[[file:src/ch9/bitree.go][二叉树]]
** 平衡二叉搜索树(AVL Tree)介绍
AVL树是一种树形数据结构,其定义如下:

1. 空树是AVL树.
2. 若 AVL 树的左子树不为空, 则其左子树上所有点的附加权值均小于其根节点的值.
3. 若 AVL 树的右子树不为空, 则其右子树上所有点的附加权值均大于其根节点的值.
4. AVL 树的左右子树均为 AVL 树.
5. 如果 T 是一棵 AVL 树, 那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \leq 1$, h 是其左右子树的高度.
6. 平衡因子: 左子树高度 - 右子树高度.

AVL树通过在插入时回溯、计算高度并判断失衡情况再进行旋转
** AVL树的接口定义
*** NewBiTree
#+begin_src go
func NewAVLTree[T cmp.Ordered]() *AVLTree[T]
#+end_src
返回值: 指向AVL树的指针.
描述: 初始化AVL树.
复杂度: O(1).
*** rotateRight
#+begin_src go
func (node *AVLNode[T]) rotateRight() *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 当节点的左子树高度过高, 且左子树的左子树是导致不平衡的主要原因时, 通过右旋转调整树结构.
复杂度: O(1)
*** rotateLeft
#+begin_src go
func (node *AVLNode[T]) rotateLeft() *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 当节点的右子树高度过高, 且右子树的右子树是导致不平衡的主要原因时, 通过左旋转调整树结构.
复杂度: O(1)
*** rotateLeftRight
#+begin_src go
func (node *AVLNode[T]) rotateLeftRight() *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 当节点的左子树高度过高, 且左子树的右子树是导致不平衡的主要原因时, 通过左右旋转调整树结构.
复杂度: O(1)
*** rotateRightLeft
#+begin_src go
func (node *AVLNode[T]) rotateRightLeft() *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 当节点的右子树高度过高, 且右子树的左子树是导致不平衡的主要原因时, 通过右左旋转调整树结构.
复杂度: O(1)
*** Insert
#+begin_src go
func (tree *AVLTree[T]) Insert(key T)
#+end_src
返回值: 无
描述: 将 key 插入进 AVL Tree
复杂度: O(log(h))
*** insertNode
#+begin_src go
func insertNode[T cmp.Ordered](node *AVLNode[T], key T) *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 将 key 插入进 node 及其子节点
复杂度: O(log(h))
*** deleteNode
#+begin_src go
func deleteNode[T cmp.Ordered](node *AVLNode[T], key T) *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 将 key 删除于 node 及其子节点
复杂度: O(log(h))
*** existNode
#+begin_src go
func existNode[T cmp.Ordered](node *AVLNode[T], key T) *AVLNode[T]
#+end_src
返回值: 指向AVL节点的指针
描述: 在 node 及其子节点查找是否存在 key
复杂度: O(log(h))
*** Destroy
#+begin_src go
func (tree *AVLTree[T]) Destory()
#+end_src
返回值: 无
描述: 销毁 AVL Tree
复杂度: O(1)
** AVL树的实现
[[file:src/ch9/bistree.go][AVL树]]
